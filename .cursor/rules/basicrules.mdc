---
alwaysApply: true
---
# Cursor Rules for Dubbing

## Project Context Management Rules
- **Always maintain project context files**: Keep /cursor-docs/CHANGELOG.md, /cursor-docs/ARCHITECTURE.md, and /cursor-docs/CURSOR-CONTEXT.md updated
- **Pattern**: `.*` (applies to all files)
- **Instructions**:
  - Whenever you create, edit, or suggest code, also update /cursor-docs/CHANGELOG.md with a dated summary of the changes. Include file paths and the reason for the change.
  - If any new folder, component, or major refactor is introduced, update /cursor-docs/ARCHITECTURE.md to reflect the current structure of the project. Include directory maps, key components, and their purpose.
  - Keep /cursor-docs/CURSOR-CONTEXT.md as a short, living summary of current features, in-progress work, dependencies, and known issues. Update this whenever features are added, modified, or removed.
  - Before suggesting or making changes, always review /cursor-docs/CURSOR-CONTEXT.md and /cursor-docs/ARCHITECTURE.md to stay aligned with the project structure and goals.

## LOGGING GUIDELINES
- **Targeted Logging Only**: Add logging only at critical points where debugging is needed
- **Maximum 3-5 logs per function**: Don't spam the console with excessive logging
- **Log only when necessary**:
  - Function entry/exit for complex functions
  - Error conditions and fallbacks
  - State changes that affect user experience
  - API call results (success/failure only)
- **Remove debug logs after fixing issues**: Don't leave excessive logging in production code
- **Use meaningful log messages**: Include relevant data, not just "function called"
- **Input Validation**: Validate all Cloud Function inputs
- **Rate Limiting**: Implement appropriate rate limiting
- **Error Messages**: Don't expose sensitive information in error responses
- **API Key Management**: Use environment variables for sensitive keys

## DEVELOPMENT WORKFLOW

### Before Making Changes
1. Check current task status and requirements
2. Research relevant documentation and examples
3. Plan implementation approach
4. Consider impact on existing functionality
5. Verify Firebase SDK version compatibility
6. Plan AI integration strategy and fallbacks
